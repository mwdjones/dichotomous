# -*- coding: utf-8 -*-
"""
Created on Thu Feb 17 16:22:47 2022

@author: M. W. Jones. 

Updated 3/3/2022 - Function script written to generate dichotomous noise (generate_noise). Generated 
solutions for the basic methane case using both numerical and analytical methods. Analytical solution looks as expected
numerical solution is off (solved). General solution for methane pdf generated using the steady state pdf.

Updated 3/14/2022 - Run code for b = 4, 1, 0.25 and stored in the triptych.pdf file in dichotomous figures

Updated 3/15/2022 - Placed analytical solver and plotting code in functions for easier application.

Update 3/16/2022 - Added the analytical solution for the pdf of phi as a function, generate pdf. 

Update 3/18/2022 - Added numerical solution for the acetate and methane equations and adjusted the equations as recorded in the slides. 
Still unsure if these are the right equations to use -- will consult with Xue on Tuesday. 

Update 3/23/2022 - Adjustments made to the equations so they are now correct and include the solution for emissions. They are currently in the 
dimensional form. 
"""
import math 
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

#%%
'''Sample Dichotomous System'''

#dC/dt = \theta(1-C), when y > yc (inundated state); -C, when c < yc (aerated state)
#State 1 --> Inundated
#State 0 --> Aerated

'''Parameters'''
#General
k1 = 1 #switching rate from state 1 to state 0
k2 = 1 #switching rate from state 0 to state 1
time = 30 #length of time
dt = 0.1 #time step 

#Data params
k_p = 2
k_ox = 1
k_om = 6
k_e = 0.2

k_max = 1
a_max = 1000

#Nondimensionalized params
#DO NOT EDIT
b = k_p/k_ox
g = k_p/k_om
e = k_e/k_max
a = 1/a_max

#%%
'''Generate Noise Using EXP'''
def generate_noise(k1, k2, num, step):
    #Takes in switching rates and generates symmetric dichotomous noise for a specified time period and step. 
    #Inputs: k1, k2 - The switching rates from state 1 to 0 and 0 to 1 respectively
    #        num - length of time 
    #        step - time step 
    #Outputs: A pandas dataframe containing two columns, one with the time and one with the noise value (either -1 or 1)
    
    #Initialize the noise
    switch = []

    #Generate random switching
    for i in range(0, num+10): #buffer
        if i%2 == 0:
            switch.append(-np.ones(int(np.random.exponential(1/k2, 1)/step)))
        else:
            switch.append(np.ones(int(np.random.exponential(1/k1, 1)/step)))
            
    #Merge frames into vector
    switch = np.concatenate(switch)
    switch = switch[0 : int(num/step)]
    
    #Generate x values
    x = np.arange(0, num, step)

    return pd.DataFrame({'x' : x,'noise' : switch})

#Generate Noise
noise = generate_noise(k1, k2, time, dt)

#Plot
plt.step(noise.x, noise.noise)
plt.xlim(0, time)
plt.xlabel('Time [t]')
plt.ylabel(r'$\xi(t)$') 

#%%
##############################################################################
######### ANALYTICAL SOLUTION - ONLY METHANE #################################
##############################################################################

'''Exponential Decay - Solving the Dynamic Equation'''
#phi(t) decreases exponentially in state 0 and increases exponentially in state 1
#i.e. phi1(t) = 1 - phi and phi2(t) = -phi

### Analytical Solution 

def solve_analytical(noise, conc_init, step, beta):
    #Takes in the noise generated by generate_noise and solved the methane equations analytically 
    #for an initial concentration.
    #Input: n - pandas dataframe containing two columns, 'x'; the time, 'noise'; the binary noise value
    #       conc_init - the initial concentration of methane 
    #       step - the time step (this should match the time step from generate_noise)
    #       beta - the beta value, i.e. the nondimensionalized constant
    #Output: noise - the input noise dataframe with four additional columns for values of f_phi, g_phi, 
    #        dphi_a, and phi_a
    
    n = pd.DataFrame({'x': noise.x, 'noise': noise.noise})
    n['f_phi'] = np.zeros(len(n.noise))
    n['g_phi'] = np.zeros(len(n.noise))
    n['dphi_a'] = np.zeros(len(n.noise))
    n['phi_a'] = np.zeros(len(n.noise))
    
    #Initial Concentration
    n.phi_a[0] = conc_init
    
    for i in range(1, len(n.phi_a)):
        n.f_phi[i] = 0.5*(beta*(1 - n.phi_a[i-1]) - n.phi_a[i-1])
        n.g_phi[i] = 0.5*(beta*(1 - n.phi_a[i-1]) + n.phi_a[i-1])
        n.dphi_a[i] = (n.f_phi[i] + n.g_phi[i]*n.noise[i])*dt
        n.phi_a[i] = n.phi_a[i-1] + n.dphi_a[i]
        
    return n

noise_4 = solve_analytical(noise, 0.5, dt, b)

#test range of b values
noise_1 = solve_analytical(noise, 0.5, dt, 1)
noise_025 = solve_analytical(noise, 0.5, dt, 0.25)

#%%
'''Plot Panel'''

def plot_noise(nplot, name):
    fig, ax = plt.subplots(3, 1, figsize=(7, 11))
    
    ax[0].step(nplot.x, nplot.noise)
    ax[0].set(xlim = (0, time))
    ax[0].set(xlabel = ' ', ylabel = r'$\xi(t)$') 
    
    ax[1].plot(nplot.x, nplot.phi_a, zorder = 0)
    ax[1].set(xlim = (0, time))
    ax[1].set(xlabel = ' ', ylabel = r'$[M]$')
    
    ax[2].plot(nplot.x, nplot.dphi_a, zorder = 0)
    ax[2].set(ylim = (-0.3, 0.3), xlim = (0, time))
    ax[2].set(xlabel = 'Time [t]', ylabel = r'$\frac{d[M]}{dt}$')
    
    plt.savefig(r"C:\Users\marie\Desktop\Feng Research\Figures\Dichotomous Modeling Figures\plot_" + str(name) + ".pdf", bbox_inches = 'tight')

#Plots
plot_noise(noise_4, 'b4')
plot_noise(noise_1, 'b1')
plot_noise(noise_025, 'b025')

#%%
'''CDF of phi'''

### Empirical cdf
fig, ax = plt.subplots()
n, bins, patches = ax.hist(noise_1.phi_a, 50, density = True, histtype = 'step', cumulative = True)
n, bins, patches = ax.hist(noise_025.phi_a, 50, density = True, histtype = 'step', cumulative = True)
n, bins, patches = ax.hist(noise_4.phi_a, 50, density = True, histtype = 'step', cumulative = True)
ax.set_xlabel(r'$[M]$')
ax.set_ylabel('Cumulative density')
plt.xlim(0, 1)
plt.legend([r'$\beta$ = 1', r'$\beta$ = 0.25', r'$\beta$ = 4'], loc = "upper left")

plt.savefig(r"C:\Users\marie\Desktop\Feng Research\Figures\Dichotomous Modeling Figures\cdf_plot.pdf", bbox_inches = 'tight')

#%%
'''Theoretical PDF'''

def generate_pdf(k1, k2, b):
    
    #Generate range of phi values
    pdf = pd.DataFrame({'phi': np.arange(0, 1, step = 0.01)})
    
    #Solve pdf equation for range of phi values
    term1 = [math.pow(value, k2) for value in pdf.phi]
    term2 = [math.pow(1 - value, k1/b) for value in pdf.phi]
    coeff = (pdf.phi + b*(1 - pdf.phi))/(pdf.phi*b*(1 - pdf.phi))
    
    pdf['pdf'] = coeff*term1*term2 
    
    #Normalize over the total sum so that the probabilities sum to one
    pdf_sum = np.sum(pdf.pdf)
    
    pdf['pdf'] = pdf.pdf/pdf_sum
    
    return pdf

#Generate sample pdf
samp_pdf = generate_pdf(k1, k2, b)
samp_pdf_1 = generate_pdf(k1, k2, 1)
samp_pdf_025 = generate_pdf(k1, k2, 0.25)

#%%
'''Plot PDF'''
plt.plot(samp_pdf_1.phi, samp_pdf_1.pdf, label = r'$\beta$ = 1')
plt.plot(samp_pdf_025.phi, samp_pdf_025.pdf, label = r'$\beta$ = 0.25')
plt.plot(samp_pdf.phi, samp_pdf.pdf, label = r'$\beta$ = 4')
plt.xlim(0, 1)
plt.xlabel(r'$[M]$')
plt.ylabel(r'$P[[M]]$')
plt.legend(loc = 'upper center')

plt.savefig(r"C:\Users\marie\Desktop\Feng Research\Figures\Dichotomous Modeling Figures\betapdf.pdf")
#%%
##############################################################################
######### NUMERICAL SOLUTION - METHANE AND ACETATE ###########################
##############################################################################

'''Equation Solver'''

def ma_equations_dim(a, m, noise, kp = k_p, kox = k_ox, kom = k_om, e = e):
    #Takes in all values necessary for solving the coupled equations for a given acetate and metane concetration
    #and then returns a 3x1 vector containing the values of d[m]dt and d[a]dt and dEdt
    #Input: a - acetate concentration
    #       m - methane concentration 
    #       k_p - Methane production rate constant (1/t)
    #       k_ox - Methane oxidation production rate constant (1/t)
    #       k_om - Acetate fermentation rate constant (1/t)
    #       e - Emission constant (dimensionless)
    #       noise - the current value for dichotomous noise, either 1 or -1. 
    #Output: sol - a vector containing the values of d[m]dt and d[a]dt and dEdt
    
    sol = []
    
    dm = 0.5*(kp*a*(1-m) - kox*m*(1-e)) + 0.5*(kp*a*(1-m) + kox*m*(1-e))*noise
    da = 0.5*(kom*(1-a) - kp*a*(1-m)) - 0.5*(kom*(1-a) + kp*a*(1 - m))*noise
    de = 0.5*(kox*e*m) - 0.5*(kox*e*m)*noise
    
    sol.append(da)
    sol.append(dm)
    sol.append(de)
    
    return np.array(sol)

'''Runge Kutta Method'''
def rk4_solve_ma(m_init, a_init, step, noise, kp = k_p, kox = k_ox, kom = k_om, e = e):
    
    s = pd.DataFrame({'Time': noise.x,
                      'Noise': noise.noise, 
                      'Acetate': np.zeros(len(noise.x)), 
                      'Methane': np.zeros(len(noise.x)),
                      'Emission': np.zeros(len(noise.x))})
    
    #Set initial conditions - Initial emission is left at 0
    s.Acetate[0], s.Methane[0],  = a_init, m_init
    
    for i in range(1, len(noise)):
        v = np.array([s.Acetate[i-1], s.Methane[i-1], s.Emission[i-1]])
        v1 = ma_equations_dim(v[0], v[1], s.Noise[i-1], kp = k_p, kox = k_ox, kom = k_om, e = e)
        tv = v + ((0.5*step)*v1)
        v2 = ma_equations_dim(tv[0], tv[1], s.Noise[i-1], kp = k_p, kox = k_ox, kom = k_om, e = e)
        tv = v + ((0.5*step)*v2)
        v3 = ma_equations_dim(tv[0], tv[1], s.Noise[i-1], kp = k_p, kox = k_ox, kom = k_om, e = e)
        tv = v + step*v3
        v4 = ma_equations_dim(tv[0], tv[1], s.Noise[i-1], kp = k_p, kox = k_ox, kom = k_om, e = e)
        
        solution = v + (step/6)*(v1 + 2*v2 + 2*v3 + v4)
        
        #Assign values back to dataframe
        s.Acetate[i], s.Methane[i], s.Emission[i] = solution[0], solution[1], solution[2]   
        
    return s

#Run algorithm
storage = rk4_solve_ma(0.5, 0.5, dt, noise, kp = k_p, kox = k_ox, kom = k_om, e = e)

storage["dEdt"] = np.concatenate(([0], np.diff(storage.Emission)))

#%%
'''Plot Solution'''
fig, ax = plt.subplots(3, 1, figsize=(7, 11))

ax[0].step(noise.x, noise.noise)
ax[0].set(xlim = (0, time))
ax[0].set(xlabel = ' ', ylabel = r'$\xi(t)$') 

ax[1].plot(storage.Time, storage.Acetate, label = 'Acetate')
ax[1].plot(storage.Time, storage.Methane, label = 'Methane')
ax[1].set(xlim = (0, 30), xlabel = ' ', ylabel = r'$[\phi]$')
ax[1].legend(loc = 'lower left')

ax[2].plot(storage.Time, storage.dEdt, label = 'Emission Rate', color = 'green')
ax[2].set(xlim = (0, 30), xlabel = 'Time [t]', ylabel = r'Emission Rate, $\frac{dE}{dt}$')

#%%
'''Empirical PDF and CDF'''

### Empirical cdf
fig, ax = plt.subplots()
n, bins, patches = ax.hist(storage.Methane, 50, density = True, histtype = 'step', cumulative = True)
n, bins, patches = ax.hist(storage.Acetate, 50, density = True, histtype = 'step', cumulative = True)
ax.set_xlabel(r'$[\phi]$')
ax.set_ylabel('Cumulative density')
plt.title("Empirical CDF of coupled Methane and Acetate")
plt.xlim(0, 1)
plt.legend(['Methane', 'Acetate'], loc = "upper left")

### Empirical pdf
fig, ax = plt.subplots()
ax.hist(storage.Methane, 50, density = True)
ax.hist(storage.Acetate, 50, density = True)
ax.set_xlabel(r'$[\phi]$')
ax.set_ylabel('Probability density')
plt.title("Empirical PDF of coupled Methane and Acetate")
plt.xlim(0, 1)
plt.legend(['Methane', 'Acetate'], loc = "upper left")


#%%
'''Simgle vs. Coupled Methane'''

### Empirical cdf
fig, ax = plt.subplots()
n, bins, patches = ax.hist(storage.Methane, 50, density = True, histtype = 'step', cumulative = True)
n, bins, patches = ax.hist(noise_4.phi_a, 50, density = True, histtype = 'step', cumulative = True)
ax.set_xlabel(r'$[M]$')
ax.set_ylabel('Cumulative density')
plt.title("Empirical CDF of methane from coupled and uncoupled solutions")
plt.xlim(0, 1)
plt.legend(['Coupled', 'Uncoupled'], loc = "upper left")

#%%

##############################################################################
######### ANALYSIS OF NUMERICAL SOLUTION FOR EMISSION ########################
##############################################################################
steps = 20

#Range of k values to test
X, Y = np.linspace(0.01, 0.99, steps), np.linspace(0.01, 0.99, steps)
Z = np.empty((steps, steps))

for i in range(0, steps):
    for j in range(0, steps):
        print("K1 is " + str(X[i]) + " and K2 is " + str(Y[j]))
        #Generate noise
        n = generate_noise(X[i], Y[j], 10, dt)
        
        #Run numerical solutions
        s = rk4_solve_ma(0.5, 0.5, dt, n, kp = k_p, kox = k_ox, kom = k_om, e = e)
        s["dEdt"] = np.concatenate(([0], np.diff(s.Emission)))

        #Take the average dEdt
        e_bar = s.dEdt.mean()
        e_max = s.Emission.max()
        
        #Test print
        print("The mean emission rate is " + str(e_bar) + " and the max emission is " + str(e_max))
        
        #Assign to the grid space
        Z[i, j] = e_bar

#%%
'''Plot the dEdt bar Contour'''

fig, ax = plt.subplots()
contour = ax.contourf(X, Y, Z, cmap = 'OrRd')
ax.set_xlabel(r'$k_1$')
ax.set_ylabel(r'$k_2$')
plt.title("Average emissions rate")
plt.xlim(0.01, 0.99)
plt.ylim(0.01, 0.99)
plt.colorbar(contour).set_label(r'Average $\frac{dE}{dt}$')
plt.show()

#%%



















