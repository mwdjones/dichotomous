# -*- coding: utf-8 -*-
"""
Created on Thu Feb 17 16:22:47 2022

@author: M. W. Jones. 

Updated 3/3/2022 - Function script written to generate dichotomous noise (generate_noise). Generated 
solutions for the basic methane case using both numerical and analytical methods. Analytical solution looks as expected
numerical solution is off (solved). General solution for methane pdf generated using the steady state pdf.

Updated 3/14/2022 - Run code for b = 4, 1, 0.25 and stored in the triptych.pdf file in dichotomous figures

Updated 3/15/2022 - Placed analytical solver and plotting code in functions for easier application.

Update 3/16/2022 - Added the analytical solution for the pdf of phi as a function, generate pdf. 
"""
import math 
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

#%%
'''Sample Dichotomous System'''

#dC/dt = \theta(1-C), when y > yc (inundated state); -C, when c < yc (aerated state)
#State 1 --> Inundated
#State 0 --> Aerated

'''Parameters'''
#General
k1 = 0.7 #switching rate from state 1 to state 0
k2 = 0.7 #switching rate from state 0 to state 1
time = 30 #length of time
dt = 0.1 #time step 

#Data params
k_p = 4
k_ox = 1
k_om = 10
k_e = 7

k_max = 20
a_max = 1000

#Nondimensionalized params
#DO NOT EDIT
b = k_p/k_ox
g = k_p/k_om
e = k_e/k_max
a = 1/a_max

#%%
'''Generate Noise Using EXP'''
def generate_noise(k1, k2, num, step):
    #Takes in switching rates and generates symmetric dichotomous noise for a specified time period and step. 
    #Inputs: k1, k2 - The switching rates from state 1 to 0 and 0 to 1 respectively
    #        num - length of time 
    #        step - time step 
    #Outputs: A pandas dataframe containing two columns, one with the time and one with the noise value (either -1 or 1)
    
    #Initialize the noise
    switch = []

    #Generate random switching
    for i in range(0, num+10): #buffer
        if i%2 == 0:
            switch.append(-np.ones(int(np.random.exponential(1/k2, 1)/step)))
        else:
            switch.append(np.ones(int(np.random.exponential(1/k1, 1)/step)))
            
    #Merge frames into vector
    switch = np.concatenate(switch)
    switch = switch[0 : int(num/step)]
    
    #Generate x values
    x = np.arange(0, num, step)

    return pd.DataFrame({'x' : x,'noise' : switch})

#Generate Noise
noise = generate_noise(k1, k2, time, dt)

#Plot
plt.step(noise.x, noise.noise)
plt.xlim(0, time)
plt.xlabel('Time [t]')
plt.ylabel(r'$\xi(t)$') 

#%%
##############################################################################
######### ANALYTICAL SOLUTION - ONLY METHANE #################################
##############################################################################

'''Exponential Decay - Solving the Dynamic Equation'''
#phi(t) decreases exponentially in state 0 and increases exponentially in state 1
#i.e. phi1(t) = 1 - phi and phi2(t) = -phi

### Analytical Solution 

def solve_analytical(noise, conc_init, step, beta):
    #Takes in the noise generated by generate_noise and solved the methane equations analytically 
    #for an initial concentration.
    #Input: n - pandas dataframe containing two columns, 'x'; the time, 'noise'; the binary noise value
    #       conc_init - the initial concentration of methane 
    #       step - the time step (this should match the time step from generate_noise)
    #       beta - the beta value, i.e. the nondimensionalized constant
    #Output: noise - the input noise dataframe with four additional columns for values of f_phi, g_phi, 
    #        dphi_a, and phi_a
    
    n = pd.DataFrame({'x': noise.x, 'noise': noise.noise})
    n['f_phi'] = np.zeros(len(n.noise))
    n['g_phi'] = np.zeros(len(n.noise))
    n['dphi_a'] = np.zeros(len(n.noise))
    n['phi_a'] = np.zeros(len(n.noise))
    
    #Initial Concentration
    n.phi_a[0] = conc_init
    
    for i in range(1, len(n.phi_a)):
        n.f_phi[i] = 0.5*(beta*(1 - n.phi_a[i-1]) - n.phi_a[i-1])
        n.g_phi[i] = 0.5*(beta*(1 - n.phi_a[i-1]) + n.phi_a[i-1])
        n.dphi_a[i] = (n.f_phi[i] + n.g_phi[i]*n.noise[i])*dt
        n.phi_a[i] = n.phi_a[i-1] + n.dphi_a[i]
        
    return n

noise_4 = solve_analytical(noise, 0.5, dt, b)

#test range of b values
noise_1 = solve_analytical(noise, 0.5, dt, 1)
noise_025 = solve_analytical(noise, 0.5, dt, 0.25)

#%%
'''Plot Panel'''

def plot_noise(nplot, name):
    fig, ax = plt.subplots(3, 1, figsize=(7, 11))
    
    ax[0].step(nplot.x, nplot.noise)
    ax[0].set(xlim = (0, time))
    ax[0].set(xlabel = ' ', ylabel = r'$\xi(t)$') 
    
    ax[1].plot(nplot.x, nplot.phi_a, zorder = 0)
    ax[1].set(xlim = (0, time))
    ax[1].set(xlabel = ' ', ylabel = r'$[M]$')
    
    ax[2].plot(nplot.x, nplot.dphi_a, zorder = 0)
    ax[2].set(ylim = (-0.3, 0.3), xlim = (0, time))
    ax[2].set(xlabel = 'Time [t]', ylabel = r'$\frac{d[M]}{dt}$')
    
    plt.savefig(r"C:\Users\marie\Desktop\Feng Research\Figures\Dichotomous Modeling Figures\plot_" + str(name) + ".pdf", bbox_inches = 'tight')

#Plots
plot_noise(noise_4, 'b4')
plot_noise(noise_1, 'b1')
plot_noise(noise_025, 'b025')

#%%
'''CDF of phi'''

### Empirical cdf
fig, ax = plt.subplots()
n, bins, patches = ax.hist(noise_1.phi_a, 50, density = True, histtype = 'step', cumulative = True)
n, bins, patches = ax.hist(noise_025.phi_a, 50, density = True, histtype = 'step', cumulative = True)
n, bins, patches = ax.hist(noise_4.phi_a, 50, density = True, histtype = 'step', cumulative = True)
ax.set_xlabel(r'$[M]$')
ax.set_ylabel('Cumulative density')
plt.xlim(0, 1)
plt.legend([r'$\beta$ = 1', r'$\beta$ = 0.25', r'$\beta$ = 4'], loc = "upper left")

plt.savefig(r"C:\Users\marie\Desktop\Feng Research\Figures\Dichotomous Modeling Figures\cdf_plot.pdf", bbox_inches = 'tight')

#%%
'''Theoretical PDF'''

def generate_pdf(k1, k2, b):
    
    #Generate range of phi values
    pdf = pd.DataFrame({'phi': np.arange(0, 1, step = 0.01)})
    
    #Solve pdf equation for range of phi values
    term1 = [math.pow(value, k2) for value in pdf.phi]
    term2 = [math.pow(1 - value, k1/b) for value in pdf.phi]
    coeff = (pdf.phi + b*(1 - pdf.phi))/(pdf.phi*b*(1 - pdf.phi))
    
    pdf['pdf'] = coeff*term1*term2 
    
    #Normalize over the total sum so that the probabilities sum to one
    pdf_sum = np.sum(pdf.pdf)
    
    pdf['pdf'] = pdf.pdf/pdf_sum
    
    return pdf

#Generate sample pdf
samp_pdf = generate_pdf(k1, k2, b)
samp_pdf_1 = generate_pdf(k1, k2, 1)
samp_pdf_025 = generate_pdf(k1, k2, 0.25)

#%%
'''Plot PDF'''
plt.plot(samp_pdf_1.phi, samp_pdf_1.pdf, label = r'$\beta$ = 1')
plt.plot(samp_pdf_025.phi, samp_pdf_025.pdf, label = r'$\beta$ = 0.25')
plt.plot(samp_pdf.phi, samp_pdf.pdf, label = r'$\beta$ = 4')
plt.xlim(0, 1)
plt.xlabel(r'$[M]$')
plt.ylabel(r'$P[[M]]$')
plt.legend(loc = 'upper center')

plt.savefig(r"C:\Users\marie\Desktop\Feng Research\Figures\Dichotomous Modeling Figures\betapdf.pdf")
#%%

##############################################################################
######### NUMERICAL SOLUTION - METHANE AND ACETATE ###########################
##############################################################################




































